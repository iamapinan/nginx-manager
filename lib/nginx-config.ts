import { ProxySite, Redirection, AccessList, Upstream } from './database';

export class NginxConfigGenerator {
  
  generateUpstreamOnlyConfig(upstreams: Upstream[]): string {
    let config = `# Generated by Nginx Manager - Upstream configurations
# DO NOT EDIT MANUALLY - This file is auto-generated

`;
    
    for (const upstream of upstreams) {
      config += `${this.generateUpstreamConfig(upstream)}

`;
    }
    
    return config;
  }

  generateSingleUpstreamConfig(upstream: Upstream): string {
    return `# Generated by Nginx Manager - Upstream configuration for ${upstream.name}
# DO NOT EDIT MANUALLY - This file is auto-generated

${this.generateUpstreamConfig(upstream)}
`;
  }
  
  generateUpstreamConfig(upstream: Upstream): string {
    let config = `upstream ${upstream.name} {`;

    // Load balancing method
    if (upstream.method !== 'round_robin') {
      if (upstream.method === 'hash' && upstream.hash_key) {
        config += `
    ${upstream.method} ${upstream.hash_key};`;
      } else {
        config += `
    ${upstream.method};`;
      }
    }

    // Servers
    for (const server of upstream.servers) {
      config += `
    server ${server.server}`;
      
      if (server.weight !== 1) {
        config += ` weight=${server.weight}`;
      }
      
      if (server.max_fails !== 1) {
        config += ` max_fails=${server.max_fails}`;
      }
      
      if (server.fail_timeout !== '10s') {
        config += ` fail_timeout=${server.fail_timeout}`;
      }
      
      if (server.backup) {
        config += ` backup`;
      }
      
      if (server.down) {
        config += ` down`;
      }
      
      config += `;`;
    }

    config += `
}`;

    return config;
  }

  generateProxyConfig(site: ProxySite, accessList?: AccessList, upstream?: Upstream): string {
    let config = `
# Proxy configuration for ${site.name}
server {
    listen 80;
    ${site.ssl ? 'listen 443 ssl http2;' : ''}
    server_name ${site.domain};

    # Client max body size
    client_max_body_size ${site.client_max_body_size || '1m'};

    ${this.generateSSLConfig(site)}
    ${this.generateSecurityConfig(site)}
    ${this.generateAccessListConfig(accessList)}
    ${this.generateCachingConfig(site, upstream)}

    location / {
        ${this.generateProxyHeaders()}`;

    // Use upstream or direct target
    if (upstream) {
      config += `
        proxy_pass http://${upstream.name};`;
    } else {
      config += `
        proxy_pass ${site.target};`;
    }

    config += `
        ${this.generateProxySettings()}
    }

    ${site.advanced_config || ''}
}

${site.ssl_forced ? this.generateRedirectToHTTPS(site.domain) : ''}
`;

    return config;
  }

  generateRedirectionConfig(redirection: Redirection): string {
    const targetUrl = redirection.preserve_path 
      ? `${redirection.target_url}$request_uri`
      : redirection.target_url;

    return `
# Redirection configuration for ${redirection.name}
server {
    listen 80;
    ${redirection.ssl ? 'listen 443 ssl http2;' : ''}
    server_name ${redirection.domain};

    ${redirection.ssl ? this.generateBasicSSLConfig(redirection.domain) : ''}

    return ${redirection.status_code} ${targetUrl};
}
`;
  }

  private generateSSLConfig(site: ProxySite): string {
    if (!site.ssl) return '';

    return `
    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/${site.domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${site.domain}/privkey.pem;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    ${site.hsts_enabled ? 'add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;' : ''}`;
  }

  private generateBasicSSLConfig(domain: string): string {
    return `
    # Basic SSL Configuration
    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;`;
  }

  private generateSecurityConfig(site: ProxySite): string {
    if (!site.block_exploits) return '';

    return `
    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # Block common exploits
    location ~* /(\\.|\\.\\.) {
        deny all;
    }
    
    location ~* \\.(aspx?|php|jsp|cgi)$ {
        deny all;
    }`;
  }

  private generateAccessListConfig(accessList?: AccessList): string {
    if (!accessList) return '';

    let config = `
    # Access List: ${accessList.name}`;

    if (accessList.pass_auth) {
      config += `
    auth_basic "${accessList.name}";
    auth_basic_user_file /etc/nginx/auth/${accessList.id}.htpasswd;`;
    }

    for (const client of accessList.clients) {
      if (client.address) {
        config += `
    ${client.directive} ${client.address};`;
      }
    }

    return config;
  }

  private generateCachingConfig(site: ProxySite, upstream?: Upstream): string {
    if (!site.caching_enabled) return '';

    const proxyPass = upstream ? `http://${upstream.name}` : site.target;

    return `
    # Caching Configuration
    location ~* \\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        proxy_pass ${proxyPass};
        ${this.generateProxyHeaders()}
    }`;
  }

  private generateProxyHeaders(): string {
    return `
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;`;
  }

  private generateProxySettings(): string {
    return `
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;`;
  }

  private generateRedirectToHTTPS(domain: string): string {
    return `
# Force HTTPS redirect for ${domain}
server {
    listen 80;
    server_name ${domain};
    return 301 https://$server_name$request_uri;
}`;
  }

  generateMainConfig(sites: ProxySite[], redirections: Redirection[], accessLists: AccessList[], upstreams: Upstream[], certificates?: any[]): string {
    let config = `
# Generated by Nginx Manager
# DO NOT EDIT MANUALLY - This file is auto-generated

# Upstream configurations
`;
    
    // Generate upstream configurations
    for (const upstream of upstreams) {
      config += `${this.generateUpstreamConfig(upstream)}

`;
    }

    // Generate access list configurations
    for (const accessList of accessLists) {
      const accessListSites = sites.filter(site => site.access_list_id === accessList.id);
      for (const site of accessListSites) {
        const upstream = site.upstream_id ? upstreams.find(u => u.id === site.upstream_id) : undefined;
        config += this.generateProxyConfig(site, accessList, upstream);
      }
    }

    // Generate regular proxy configurations
    const regularSites = sites.filter(site => !site.access_list_id);
    for (const site of regularSites) {
      const upstream = site.upstream_id ? upstreams.find(u => u.id === site.upstream_id) : undefined;
      config += this.generateProxyConfig(site, undefined, upstream);
    }

    // Generate redirection configurations
    for (const redirection of redirections) {
      config += this.generateRedirectionConfig(redirection);
    }

    return config;
  }
}

export const nginxConfigGenerator = new NginxConfigGenerator(); 